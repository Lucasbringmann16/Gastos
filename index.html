<script type="text/javascript">
    // Script GK (inicial) - Mantido como no seu original
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }
</script>
<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gastos v1</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#28a745">
    <link rel="icon" type="image/png" href="https://img.icons8.com/ios-filled/50/000000/money-bag.png">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
        integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
        crossorigin="anonymous">
    <style>
        :root {
            --background-color: #f5f7fa;
            --container-background: #ffffff;
            --text-color: #2d3436;
            --border-color: #e0e0e0;
            --table-header-bg: #f8f9fa;
            --button-add-bg: #28a745;
            --button-add-hover: #218838;
            --button-cancel-bg: #6c757d;
            --button-cancel-hover: #5a6268;
            --button-delete-bg: #dc3545;
            --button-delete-hover: #c82333;
            --button-edit-bg: #007bff;
            --button-edit-hover: #0056b3;
            --total-bg: #e7f3ff;
            --total-color: #007bff;
            --remaining-bg: #e6ffed;
            --remaining-color: #28a745;
            --remaining-negative-bg: #ffe6e6;
            --remaining-negative-color: #dc3545;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --card-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            --transition: all 0.3s ease;
        }

        [data-theme="dark"] {
            --background-color: #121212;
            --container-background: #1e1e1e;
            --text-color: #e0e0e0;
            --border-color: #444;
            --table-header-bg: #2c2c2c;
            --button-add-bg: #2ecc71;
            --button-add-hover: #27ae60;
            --button-cancel-bg: #95a5a6;
            --button-cancel-hover: #7f8c8d;
            --button-delete-bg: #e74c3c;
            --button-delete-hover: #c0392b;
            --button-edit-bg: #3498db;
            --button-edit-hover: #2980b9;
            --total-bg: #1a2634;
            --total-color: #66b0ff;
            --remaining-bg: #1a2e24;
            --remaining-color: #2ecc71;
            --remaining-negative-bg: #2e1a1a;
            --remaining-negative-color: #e74c3c;
            --shadow-color: rgba(255, 255, 255, 0.1);
            --card-shadow: 0 4px 10px rgba(255, 255, 255, 0.05);
        }

        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: var(--transition);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--container-background);
            padding: 25px;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            transition: var(--transition);
            position: relative;
        }

        .login-container {
            max-width: 400px;
            margin: 100px auto;
            background: var(--container-background);
            padding: 25px;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            text-align: center;
        }

        .login-container h2 {
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .login-container input {
            /* Estilo não usado mais para login, mas mantido */
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: 'Poppins', sans-serif;
        }

        .login-container button {
            /* Estilo para o botão de login com Google */
            background: var(--button-add-bg);
            /* Pode querer um estilo específico para Google, ex: #4285F4 */
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            /* Para alinhar ícone e texto */
            align-items: center;
            gap: 8px;
        }

        .login-container button:hover {
            background: var(--button-add-hover);
            /* Ou um hover específico para Google */
        }

        .login-container .form-group {
            text-align: left;
            margin-bottom: 15px;
        }

        .login-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .login-container input[type="email"],
        .login-container input[type="password"] {
            width: 100%;
            padding: 12px;
            margin: 0;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: 'Poppins', sans-serif;
            box-sizing: border-box;
            /* Essencial */
            background-color: var(--background-color);
            color: var(--text-color);
        }

        .login-container .auth-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .login-container .auth-actions button {
            flex-grow: 1;
            background: var(--button-add-bg);
            color: #fff;
            border: none;
            padding: 12px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 500;
        }

        .login-container .auth-actions button#registerBtn {
            background: var(--button-secondary-bg, #6c757d);
            /* Cor secundária */
        }

        .login-container .auth-actions button:hover {
            opacity: 0.9;
        }

        .login-container .divider {
            display: flex;
            align-items: center;
            text-align: center;
            color: #aaa;
            margin: 25px 0;
        }

        .login-container .divider::before,
        .login-container .divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid var(--border-color);
        }

        .login-container .divider:not(:empty)::before {
            margin-right: .25em;
        }

        .login-container .divider:not(:empty)::after {
            margin-left: .25em;
        }

        .login-container #googleSignInBtn {
            background: #4285F4;
            padding: 12px 20px;
            width: 100%;
            justify-content: center;
            font-weight: 500;
        }

        .login-container #googleSignInBtn:hover {
            background: #357ae8;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            flex-wrap: wrap;
            margin-left: 15px;
            margin-right: 15px;
        }

        .header h1 {
            font-size: 1.8em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0;
        }

        .header h1 i {
            color: var(--button-add-bg);
        }

        .menu-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            transition: var(--transition);
        }

        .menu-button i {
            font-size: 24px;
            color: var(--text-color);
        }

        .menu-button:hover i {
            color: var(--button-add-bg);
        }

        .settings-menu {
            display: none;
            position: absolute;
            top: 60px;
            right: 20px;
            background: var(--container-background);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            padding: 10px;
            z-index: 1000;
            min-width: 200px;
        }

        .settings-menu.active {
            display: block;
        }

        .settings-menu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .settings-menu li {
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: var(--text-color);
            font-size: 0.95em;
        }

        .settings-menu li i {
            margin-right: 8px;
            color: var(--button-add-bg);
        }

        .settings-menu input[type="number"] {
            width: 50px;
            padding: 6px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--container-background);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
        }

        /* Estilo para o slider do modo escuro (se não existir, adicione) */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            /* Ajuste o tamanho conforme necessário */
            height: 20px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
            /* Para torná-lo arredondado */
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            /* Ajuste o tamanho do círculo */
            width: 14px;
            left: 3px;
            /* Posição inicial do círculo */
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--button-add-bg);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
            /* Distância que o círculo se move */
        }


        .month-selector {
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-left: 15px;
            margin-right: 15px;
        }

        .month-selector label {
            font-weight: 500;
            font-size: 0.95em;
        }

        .month-selector select {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--container-background);
            color: var(--text-color);
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-size: 0.95em;
            transition: var(--transition);
        }

        .month-selector select:focus {
            outline: none;
            border-color: var(--button-add-bg);
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.2);
        }

        .privacy-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            transition: var(--transition);
        }

        .privacy-button i {
            font-size: 18px;
            color: var(--text-color);
        }

        .privacy-button:hover i {
            color: var(--button-add-bg);
        }

        .input-section {
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            background: var(--container-background);
            padding: 15px;
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            margin-left: 15px;
            margin-right: 15px;
        }

        .input-section .recurring-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
        }

        .type-selector {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .type-selector label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
        }

        .salary-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .salary-section .salary-value {
            color: var(--remaining-color);
            font-weight: 500;
            font-size: 0.95em;
        }

        .input-section input,
        .input-section button,
        .salary-section input,
        .salary-section button {
            padding: 6px 12px;
            margin: 0;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--container-background);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            font-size: 0.95em;
            transition: var(--transition);
        }

        .input-section input:focus,
        .salary-section input:focus {
            outline: none;
            border-color: var(--button-add-bg);
            box-shadow: 0 0 5px rgba(40, 167, 69, 0.2);
        }

        .input-section button,
        .salary-section button {
            /* Estilo para botões Adicionar, Cancelar, e botão de Salário */
            background: linear-gradient(135deg, var(--button-add-bg), var(--button-add-hover));
            color: #fff;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .input-section button:hover,
        .salary-section button:hover {
            background: var(--button-add-hover);
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }

        .input-section .cancel-btn {
            background: linear-gradient(135deg, var(--button-cancel-bg), var(--button-cancel-hover));
        }

        .input-section .cancel-btn:hover {
            background: var(--button-cancel-hover);
            box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3);
        }

        table {
            width: calc(100% - 30px);
            margin: 0 15px;
            border-collapse: collapse;
            margin-bottom: 25px;
            background: var(--container-background);
            border-radius: 8px;
            box-shadow: var(--card-shadow);
        }

        table,
        th,
        td {
            border: none;
        }

        th,
        td {
            padding: 12px 15px;
            text-align: left;
            color: var(--text-color);
            font-size: 0.9em;
        }

        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
        }

        tr {
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }

        tr:last-child {
            border-bottom: none;
        }

        tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.02);
        }

        tr:nth-child(even)[data-theme="dark"] {
            background-color: rgba(255, 255, 255, 0.02);
        }

        tr:hover {
            background-color: rgba(40, 167, 69, 0.05);
        }

        .delete-btn,
        .edit-btn {
            /* Estilos consolidados para botões de ação da tabela */
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .delete-btn {
            background: linear-gradient(135deg, var(--button-delete-bg), var(--button-delete-hover));
            margin-right: 6px;
            /* Mantido se desejado */
        }

        .delete-btn:hover {
            background: var(--button-delete-hover);
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        }

        .edit-btn {
            background: linear-gradient(135deg, var(--button-edit-bg), var(--button-edit-hover));
        }

        .edit-btn:hover {
            background: var(--button-edit-hover);
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
        }

        .recurring-icon {
            color: var(--button-add-bg);
            margin-left: 5px;
        }

        .paid-icon {
            color: var(--button-add-bg);
            margin-right: 5px;
        }

        .total,
        .remaining,
        .to-pay {
            font-size: 1.1em;
            font-weight: 500;
            text-align: right;
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 6px;
            display: inline-block;
            /* Ou flex se precisar de mais controle interno */
            margin-left: 15px;
            /* Cuidado com múltiplos elementos inline-block e espaçamento */
            margin-right: 15px;
        }

        .total {
            background-color: var(--total-bg);
            color: var(--total-color);
        }

        .remaining {
            background-color: var(--remaining-bg);
            color: var(--remaining-color);
        }

        .remaining.negative {
            background-color: var(--remaining-negative-bg);
            color: var(--remaining-negative-color);
        }

        .to-pay {
            background-color: var(--remaining-bg);
            color: var(--remaining-color);
        }

        /* Ajustar se necessário para diferenciar de 'remaining' */
        .to-pay.negative {
            background-color: var(--remaining-negative-bg);
            color: var(--remaining-negative-color);
        }

        .chart-container {
            background: var(--container-background);
            padding: 15px;
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            margin-top: 25px;
            margin-left: 15px;
            margin-right: 15px;
        }

        canvas {
            max-width: 100%;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        tr {
            animation: fadeIn 0.3s ease;
        }

        /* Media Queries Mantidas como no seu original */
        @media (max-width: 600px) {
            /* ... */
        }

        @media (max-width: 400px) {
            /* ... */
        }

        @media (max-width: 768px) {

            /* Você pode ajustar este breakpoint se necessário */
            .input-section {
                gap: 10px;
                /* Reduzir o espaço entre os itens */
            }

            .input-section input[type="text"],
            .input-section input[type="number"],
            .input-section input[type="date"] {
                flex-grow: 1;
                /* Permite que cresçam para preencher o espaço */
                flex-basis: calc(50% - 10px);
                /* Tenta colocar 2 por linha, ajuste o '10px' conforme o gap */
                min-width: 180px;
                /* Um mínimo para não ficarem muito pequenos antes de quebrar */
                box-sizing: border-box;
            }

            .input-section .type-selector,
            .input-section .recurring-label {
                flex-basis: 100%;
                /* Faz com que ocupem a linha inteira */
                margin-top: 5px;
            }

            .input-section button#addBtn,
            .input-section button#cancelBtn {
                flex-basis: 100%;
                /* Botões principais ocupam a linha toda */
                margin-top: 10px;
            }
        }

        /* Para telas realmente pequenas (como nos seus prints de 375px, 412px), empilhar é mais seguro */
        @media (max-width: 600px) {
            .input-section {
                flex-direction: column;
                /* Empilha todos os itens verticalmente */
                align-items: stretch;
                /* Faz com que os itens se estiquem na largura */
                gap: 12px;
                /* Ajuste o espaçamento vertical */
                /* Remova margin-left e margin-right se quiser que ocupe 100% do container,
           ou ajuste o padding do .container */
                margin-left: 0;
                margin-right: 0;
                padding: 15px;
                /* Manter um padding interno */

            }

            .input-section input[type="text"],
            .input-section input[type="number"],
            .input-section input[type="date"],
            .input-section .type-selector,
            .input-section .recurring-label,
            .input-section button {
                /* Aplica a todos os filhos diretos que são inputs ou botões */
                width: 100%;
                /* Ocupam toda a largura disponível */
                box-sizing: border-box;
                /* Importante para o cálculo da largura */
                margin-bottom: 8px;
                /* Espaçamento entre itens empilhados */
            }

            .input-section button {
                margin-top: 5px;
                /* Um pouco de espaço antes dos botões */
            }

            .input-section .type-selector {
                justify-content: flex-start;
                /* Alinha os radios no início */
                gap: 15px;
                /* Espaço entre os radios */
            }

            .input-section .recurring-label {
                justify-content: flex-start;
            }

            /* Seus ajustes de padding e font-size existentes para 600px: */
            .input-section input,
            .input-section button {
                /* Já estava no seu código, pode manter/ajustar */
                /* padding: 8px 12px; */
                /* O padding já está no seletor mais genérico acima */
                font-size: 0.9em;
            }
        }

        /* Ajustes ainda menores para 400px, se necessário, refinando o de 600px */
        @media (max-width: 400px) {
            .input-section {
                padding: 10px;
                /* Menos padding no container do input */
                gap: 10px;
            }

            .input-section input,
            .input-section button {
                font-size: 0.85em;
                /* Fontes um pouco menores */
                /* padding: 6px 10px; */
                /* O padding já está no seletor mais genérico acima */
            }

            .input-section button {
                /* Herda width 100% de cima */
                padding-top: 8px;
                padding-bottom: 8px;
            }
        }

        /* Adicione este CSS fora de qualquer media query (estilos base) */
        .table-responsive-wrapper {
            overflow-x: auto;
            /* ESSENCIAL: permite rolagem horizontal apenas para este container */
            width: 100%;
            /* O wrapper ocupa a largura total disponível */
            -webkit-overflow-scrolling: touch;
            /* Para uma rolagem mais suave em iOS */
            margin-bottom: 25px;
            /* Mantém a margem que a tabela tinha */
        }

        table#entryTable {
            width: 100%;
            /* A tabela tenta ocupar 100% do seu wrapper (que agora é rolável) */
            min-width: 500px;
            /* Opcional: defina uma largura mínima para a tabela,
                            abaixo da qual a rolagem horizontal começará.
                            Ajuste este valor conforme o conteúdo da sua tabela. */
            margin: 0;
            /* Remove as margens laterais da tabela, pois o wrapper controla */
            /* Seus outros estilos de tabela como border-collapse, etc., continuam aqui */
        }

        /* Ajustes dentro das Media Queries para a tabela */
        @media (max-width: 600px) {

            /* Seus ajustes de padding e font-size existentes para 600px para th, td: */
            table#entryTable th,
            table#entryTable td {
                padding: 10px 8px;
                /* Reduzir padding lateral */
                font-size: 0.85em;
                white-space: nowrap;
                /* Evita que o conteúdo das células quebre em várias linhas,
                                 forçando a rolagem se necessário. Opcional. */
            }

            table#entryTable .edit-btn,
            table#entryTable .delete-btn {
                padding: 5px 8px;
                /* Botões menores */
                font-size: 0.8em;
                /* Fonte menor nos botões */
            }

            /* Opcional: Fazer botões de ação empilharem ou ocuparem menos espaço */
            table#entryTable td:last-child {
                /* Coluna "Ação" */
                min-width: 110px;
                /* Garante um espaço mínimo para os botões lado a lado */
            }
        }

        @media (max-width: 400px) {

            /* Seus ajustes de padding e font-size existentes para 400px para th, td: */
            table#entryTable th,
            table#entryTable td {
                padding: 8px 5px;
                /* Padding ainda menor */
                font-size: 0.8em;
                /* Fonte ainda menor */
            }

            table#entryTable .edit-btn,
            table#entryTable .delete-btn {
                padding: 4px 6px;
                font-size: 0.75em;
            }

            /* Em telas muito pequenas, pode ser útil empilhar os botões de ação */
            table#entryTable td:last-child button {
                display: block;
                /* Faz cada botão ocupar uma linha */
                width: 100%;
                /* Ocupa toda a largura da célula (ou do bloco) */
                margin-bottom: 4px;
                /* Espaço entre botões empilhados */
                box-sizing: border-box;
            }

            table#entryTable td:last-child button:last-child {
                margin-bottom: 0;
                /* Remove a margem do último botão */
            }

            table#entryTable td:last-child {
                min-width: 80px;
                /* Ajusta o min-width para quando os botões estão empilhados */
            }
        }
    </style>
</head>

<body>
    <div id="loginScreen" class="login-container">
        <h2>Acessar Gastos v1</h2>

        <!-- Novos campos para E-mail e Senha -->
        <div class="form-group">
            <label for="emailInput">E-mail</label>
            <input type="email" id="emailInput" placeholder="seu@email.com" autocomplete="email">
        </div>
        <div class="form-group">
            <label for="passwordInput">Senha</label>
            <input type="password" id="passwordInput" placeholder="••••••••" autocomplete="current-password">
        </div>

        <!-- Novos botões de Ação -->
        <div class="auth-actions">
            <button id="loginBtn">Entrar</button>
            <button id="registerBtn">Registrar</button>
        </div>

        <!-- Divisor visual -->
        <div class="divider">ou</div>

        <!-- Botão do Google que já existia -->
        <button id="googleSignInBtn">
            <i class="fab fa-google"></i> Continuar com Google
        </button>
    </div>

    <div id="mainApp" class="container" style="display: none;">
        <div class="header">
            <h1><i class="fas fa-wallet"></i> Gastos v1</h1>
            <button class="menu-button" id="settingsMenuBtn"> <i class="fas fa-gear"></i>
            </button>
        </div>
        <div class="settings-menu" id="settingsMenu">
            <ul>
                <li>
                    <span><i class="fas fa-moon"></i> Modo Escuro</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="darkModeToggle">
                        <span class="slider"></span>
                    </label>
                </li>
                <li>
                    <span><i class="fas fa-calendar-day"></i> Dia de Pagamento</span>
                    <input type="number" id="paymentDay" min="1" max="31" value="1">
                </li>
                <li>
                    <span><i class="fas fa-money-bill-wave"></i> Definir Salário</span>
                    <div class="salary-section">
                        <input type="number" id="salaryAmount" placeholder="R$" step="0.01">
                        <button id="setSalaryBtn"><i class="fas fa-check"></i></button>
                        <span id="currentSalary" class="salary-value"></span>
                    </div>
                </li>
                <li>
                    <span><i class="fas fa-sign-out-alt"></i> Sair</span>
                    <button id="signOutBtn"
                        style="background: var(--button-delete-bg); color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer;"><i
                            class="fas fa-sign-out-alt"></i>
                    </button>
                </li>
            </ul>
        </div>
        <div class="month-selector">
            <label for="monthSelect">Selecione o Mês:</label>
            <select id="monthSelect">
                <option value="Janeiro">Janeiro</option>
                <option value="Fevereiro">Fevereiro</option>
                <option value="Março">Março</option>
                <option value="Abril">Abril</option>
                <option value="Maio">Maio</option>
                <option value="Junho">Junho</option>
                <option value="Julho">Julho</option>
                <option value="Agosto">Agosto</option>
                <option value="Setembro">Setembro</option>
                <option value="Outubro">Outubro</option>
                <option value="Novembro">Novembro</option>
                <option value="Dezembro">Dezembro</option>
            </select>
            <button id="privacyToggle" class="privacy-button">
                <i class="fas fa-eye"></i>
            </button>
        </div>
        <div class="input-section">
            <input type="text" id="entryName" placeholder="Nome">
            <input type="number" id="entryAmount" placeholder="Valor (R$)" step="0.01">
            <input type="date" id="entryDate" required>
            <div class="type-selector">
                <label>
                    <input type="radio" name="entryType" value="expense" checked>
                    Gasto
                </label>
                <label>
                    <input type="radio" name="entryType" value="income">
                    Renda
                </label>
            </div>
            <label class="recurring-label" id="recurringOption">
                <input type="checkbox" id="isRecurring">
                Recorrente
            </label>
            <button id="addBtn"> <i class="fas fa-plus"></i> Adicionar</button>
            <button id="cancelBtn" class="cancel-btn" style="display: none;"><i class="fas fa-times"></i>
                Cancelar</button>
        </div>
        <div class="table-responsive-wrapper">
            <table id="entryTable">
                <thead>
                    <tr>
                        <th>Descrição</th>
                        <th>Valor (R$)</th>
                        <th>Data</th>
                        <th>Ação</th>
                    </tr>
                </thead>
                <tbody id="entryTableBody"></tbody>
            </table>
        </div>
        <div class="total" id="totalAmount">Total de Gastos: R$ 0,00</div>
        <div class="remaining" id="remainingAmount">Restante: R$ 0,00</div>
        <div class="to-pay" id="toPayAmount">A pagar: R$ 0,00</div>
        <div class="chart-container">
            <canvas id="entryChart"></canvas>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import {
            getAuth,
            GoogleAuthProvider,
            signInWithPopup,
            onAuthStateChanged,
            signOut,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
        import { getDatabase, ref, set, onValue, remove } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-database.js";
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-analytics.js"; // Analytics comentado

        const firebaseConfig = {
            apiKey: "AIzaSyABRIh096KhMi_iQ55tA892tgBMR2Qj9Pw", // Substitua pela sua chave real se esta for de exemplo
            authDomain: "gastos-v1-f6461.firebaseapp.com",
            projectId: "gastos-v1-f6461",
            storageBucket: "gastos-v1-f6461.firebasestorage.app",
            messagingSenderId: "306766635139",
            appId: "1:306766635139:web:aaee04c71a9b166583fbb6",
            measurementId: "G-Z1BVSQ5C80"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const database = getDatabase(app);
        // const analytics = getAnalytics(app); // Analytics comentado

        // --- Funções de Autenticação Firebase ---
        function handleRegistration() {
            const email = document.getElementById('emailInput').value;
            const password = document.getElementById('passwordInput').value;
            if (!email || password.length < 6) {
                alert("Por favor, insira um e-mail válido e uma senha com pelo menos 6 caracteres.");
                return;
            }
            createUserWithEmailAndPassword(auth, email, password)
                .then((userCredential) => {
                    console.log("Usuário registrado com sucesso:", userCredential.user);
                    // O onAuthStateChanged vai lidar com a atualização da UI, então não precisamos fazer nada aqui.
                })
                .catch((error) => {
                    console.error("Erro no registro:", error.code, error.message);
                    if (error.code === 'auth/email-already-in-use') {
                        alert("Este e-mail já está em uso. Tente fazer login.");
                    } else {
                        alert("Erro ao registrar: " + error.message);
                    }
                });
        }

        function handleLogin() {
            const email = document.getElementById('emailInput').value;
            const password = document.getElementById('passwordInput').value;
            if (!email || !password) {
                alert("Por favor, insira e-mail e senha.");
                return;
            }
            signInWithEmailAndPassword(auth, email, password)
                .then((userCredential) => {
                    console.log("Usuário logado com sucesso:", userCredential.user);
                    // O onAuthStateChanged vai lidar com a atualização da UI.
                })
                .catch((error) => {
                    console.error("Erro no login:", error.code, error.message);
                    if (error.code === 'auth/invalid-credential' || error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found') {
                        alert("E-mail ou senha incorretos.");
                    } else {
                        alert("Erro ao fazer login: " + error.message);
                    }
                });
        }

        function signInWithGoogle() {
            const provider = new GoogleAuthProvider();
            signInWithPopup(auth, provider)
                .then((result) => {
                    const user = result.user;
                    console.log('Usuário logado:', user.displayName, user.email, user.uid);
                })
                .catch((error) => {
                    console.error('Erro ao fazer login com Google:', error.code, error.message);
                    if (error.code === 'auth/popup-closed-by-user') {
                        alert('A janela de login foi fechada antes da conclusão.');
                    } else if (error.code === 'auth/cancelled-popup-request') {
                        // Não mostrar alerta para este caso, pois pode ser comum.
                        console.warn('Múltiplas janelas de login solicitadas ou uma cancelada.');
                    } else {
                        alert('Erro ao fazer login: ' + error.message);
                    }
                });
        }

        function signOutUser() {
            signOut(auth).then(() => {
                console.log('Usuário deslogado com sucesso.');
                // Limpeza de dados em memória ao deslogar
                entries = [];
                salary = 0;
                monthlyData = {};
                // Outras limpezas podem ser necessárias
                // Por exemplo, limpar a tabela explicitamente se `setupAppUI` não fizer isso ao ser chamado sem usuário
                const tableBody = document.getElementById('entryTableBody');
                if (tableBody) tableBody.innerHTML = '';
                document.getElementById('totalAmount').textContent = 'Total de Gastos: R$ 0,00';
                document.getElementById('remainingAmount').textContent = 'Restante: R$ 0,00';
                document.getElementById('toPayAmount').textContent = 'A pagar: R$ 0,00';
                if (chart) chart.destroy(); // Destruir o gráfico ao deslogar
            }).catch((error) => {
                console.error('Erro ao fazer logout:', error.message);
                alert('Erro ao fazer logout: ' + error.message);
            });
        }

        onAuthStateChanged(auth, (user) => {
            if (user) {
                console.log('onAuthStateChanged: Usuário logado', user.uid);
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('mainApp').style.display = 'block';
                setupAppUI(); // Carrega dados e inicializa a UI para o usuário logado
            } else {
                console.log('onAuthStateChanged: Usuário deslogado');
                document.getElementById('loginScreen').style.display = 'block';
                document.getElementById('mainApp').style.display = 'none';
                const menu = document.getElementById('settingsMenu');
                if (menu && menu.classList.contains('active')) {
                    menu.classList.remove('active');
                }
            }
        });

        // --- Funções do Aplicativo ---
        // (Mantenha todas as suas funções de lógica do aplicativo aqui: setupAppUI, toggleSettingsMenu, etc.)
        const months = [
            "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
            "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
        ];

        let monthlyData = {}; // Será preenchido pelo Firebase ou localStorage se não houver usuário
        let currentMonth = getCurrentMonthFromServerOrLocal(); // Ajustado para refletir a nova abordagem
        let entries = [];
        let salary = 0;
        let chart;
        let editingIndex = null;
        let isPrivacyMode = localStorage.getItem('app2_privacyMode') === 'true' || false; // Mantém localStorage para preferência de UI

        function setupAppUI() {
            // Esta função agora será responsável por carregar os dados (do Firebase) e configurar a UI
            // A lógica de `initializeMonthlyData` e `loadMonthData` será adaptada para Firebase
            loadTheme(); // Preferências de UI podem vir do localStorage
            loadPaymentDay(); // Preferências de UI podem vir do localStorage

            const privacyIcon = document.getElementById('privacyToggle').querySelector('i');
            privacyIcon.classList.toggle('fa-eye', !isPrivacyMode);
            privacyIcon.classList.toggle('fa-eye-slash', isPrivacyMode);

            // A chamada para carregar dados do mês (ex: loadMonthData()) deve ocorrer aqui,
            // mas agora ela buscará dados do Firebase.
            // O `onAuthStateChanged` já chama `setupAppUI`.
            // `loadMonthData` será chamada por `setupAppUI` ou por `changeMonth`.
            // Precisamos garantir que `currentMonth` esteja definido antes de chamar `loadMonthData`.
            setDefaultMonth(); // Define o select para o mês atual
            loadMonthData(); // Carrega os dados para o mês selecionado (agora do Firebase)
            // toggleRecurringOption(); // Esta função parece apenas mostrar o elemento, o que pode ser feito no HTML ou CSS
        }

        function getCurrentMonthFromServerOrLocal() { // Nome alterado para clareza
            // A lógica original de `getCurrentMonth` pode ser mantida, pois é baseada na data do cliente
            const today = new Date();
            const currentDay = today.getDate();
            const currentMonthIndex = today.getMonth();
            const paymentDay = parseInt(localStorage.getItem('app2_paymentDay')) || 1; // Preferência local

            if (currentDay > paymentDay && currentMonthIndex < 11) {
                return months[currentMonthIndex + 1];
            }
            return months[currentMonthIndex];
        }

        function initializeMonthlyData() {
            // Com Firebase, esta função pode mudar.
            // Se um usuário novo faz login, pode não haver dados.
            // Podemos garantir que a estrutura para cada mês exista no objeto `monthlyData` local
            // antes de tentar acessá-lo.
            // O Firebase retornará `null` se um caminho não existir, o que `loadMonthData` já trata com `|| {}` e `|| []`.
            // Esta função pode não ser mais tão necessária para *criar* dados no localStorage.
            // No contexto do Firebase, ela pode ser usada para garantir que o objeto `monthlyData` local tenha a estrutura.
            let dataChanged = false;
            months.forEach(month => {
                if (!monthlyData[month]) {
                    monthlyData[month] = { entries: [], salary: 0 };
                    dataChanged = true; // Indica que a estrutura local foi modificada
                } else if (!monthlyData[month].entries) { // Garante que entries exista
                    monthlyData[month].entries = [];
                    dataChanged = true;
                } else if (monthlyData[month].expenses) { // Migração de formato antigo (se aplicável)
                    monthlyData[month].entries = monthlyData[month].expenses.map(expense => ({
                        ...expense,
                        type: 'expense',
                        isPaid: false
                    }));
                    delete monthlyData[month].expenses;
                    dataChanged = true;
                }
                if (typeof monthlyData[month].salary === 'undefined') {
                    monthlyData[month].salary = 0;
                    dataChanged = true;
                }
            });
            // Não chamar saveMonthlyData() aqui se estivermos apenas inicializando a estrutura local
            // A leitura do Firebase (onValue) trará os dados, e o saveMonthlyData só deve ocorrer em mudanças explícitas.
        }

        function saveMonthlyData() {
            const user = auth.currentUser;
            if (user && currentMonth) { // Salva apenas o mês atual
                const monthDataRef = ref(database, `users/${user.uid}/monthlyData/${currentMonth}`);
                const dataToSave = {
                    entries: monthlyData[currentMonth]?.entries || [],
                    salary: monthlyData[currentMonth]?.salary || 0
                };
                set(monthDataRef, dataToSave)
                    .then(() => {
                        console.log(`Dados para ${currentMonth} salvos no Firebase.`);
                    })
                    .catch((error) => {
                        console.error(`Erro ao salvar dados de ${currentMonth} no Firebase:`, error);
                    });
            } else if (!user) {
                // Se não houver usuário, talvez salvar no localStorage como fallback (se desejado)
                // localStorage.setItem('app2_monthlyData_local', JSON.stringify(monthlyData));
                console.log("Nenhum usuário logado, dados não salvos no Firebase. (Salvo localmente se implementado)");
            }
        }

        function loadMonthData() {
            const user = auth.currentUser;
            const selectedMonth = document.getElementById('monthSelect').value;
            currentMonth = selectedMonth; // Atualiza o mês corrente globalmente

            if (user) {
                const userMonthlyDataRef = ref(database, `users/${user.uid}/monthlyData`);
                onValue(userMonthlyDataRef, (snapshot) => {
                    const allDataFromFirebase = snapshot.val() || {};
                    monthlyData = allDataFromFirebase; // Atualiza a variável global com todos os dados do usuário

                    // Garante que a estrutura para todos os meses exista no objeto monthlyData local
                    initializeMonthlyData(); // Garante a estrutura local, não salva no Firebase aqui

                    // Agora processa os dados para o currentMonth específico
                    entries = monthlyData[currentMonth]?.entries || [];
                    salary = monthlyData[currentMonth]?.salary || 0;

                    console.log(`Dados carregados para ${currentMonth} do Firebase:`, monthlyData[currentMonth]);

                    updateUIComponents(); // Função central para atualizar toda a UI
                }, { onlyOnce: true }); // onlyOnce: true para carregar uma vez, ajuste se precisar de tempo real constante
            } else {
                // Lógica para quando não há usuário (ex: carregar do localStorage ou mostrar estado vazio)
                console.log("Nenhum usuário logado, carregando dados de fallback ou estado vazio.");
                // monthlyData = JSON.parse(localStorage.getItem('app2_monthlyData_local')) || {};
                initializeMonthlyData(); // Garante a estrutura no monthlyData local
                entries = monthlyData[currentMonth]?.entries || [];
                salary = monthlyData[currentMonth]?.salary || 0;
                updateUIComponents();
            }
        }

        function updateUIComponents() {
            updateTable();
            updateSalaryDisplay();
            updateRemaining(); // updateRemaining chama updateTotal
            updateChart();
            updateToPay();
        }


        function setDefaultMonth() {
            const monthSelect = document.getElementById('monthSelect');
            monthSelect.value = currentMonth; // currentMonth já deve estar definido
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js') // Verifique se o caminho para sw.js está correto
                    .then(registration => {
                        console.log('Service Worker registrado com sucesso:', registration);
                    })
                    .catch(error => {
                        console.error('Erro ao registrar o Service Worker:', error);
                    });
            });
        }

        function toggleSettingsMenu() {
            const menu = document.getElementById('settingsMenu');
            if (menu) {
                menu.classList.toggle('active');
            }
        }

        function toggleTheme() {
            const body = document.body;
            const isDark = body.getAttribute('data-theme') === 'dark';
            const newTheme = isDark ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            document.getElementById('darkModeToggle').checked = (newTheme === 'dark');
            localStorage.setItem('app2_theme', newTheme); // Salva preferência de tema
            updateChart(); // Atualiza o gráfico com o novo tema
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('app2_theme') || 'light';
            document.body.setAttribute('data-theme', savedTheme);
            const darkModeToggle = document.getElementById('darkModeToggle');
            if (darkModeToggle) darkModeToggle.checked = savedTheme === 'dark';
        }

        function setPaymentDay() {
            const paymentDayInput = document.getElementById('paymentDay');
            let paymentDay = parseInt(paymentDayInput.value);
            if (isNaN(paymentDay) || paymentDay < 1 || paymentDay > 31) {
                paymentDay = 1; // Valor padrão
                paymentDayInput.value = paymentDay;
            }
            localStorage.setItem('app2_paymentDay', paymentDay.toString());
            // Recalcular o mês atual e recarregar os dados pode ser necessário
            // se a lógica de getCurrentMonthFromServerOrLocal depender disso de forma crítica
            // para a seleção inicial.
            // Por ora, apenas salva. Se a mudança de mês for afetada, o usuário pode ter que re-selecionar.
            // Ou, se quiser auto-atualizar:
            // currentMonth = getCurrentMonthFromServerOrLocal();
            // setDefaultMonth();
            // loadMonthData();
        }

        function loadPaymentDay() {
            const paymentDay = localStorage.getItem('app2_paymentDay') || "1";
            const paymentDayInput = document.getElementById('paymentDay');
            if (paymentDayInput) paymentDayInput.value = paymentDay;
        }

        function formatCurrency(value) {
            return `R$ ${parseFloat(value).toFixed(2).replace('.', ',')}`;
        }

        function formatDate(dateString) {
            if (!dateString || typeof dateString !== 'string' || !dateString.includes('-')) {
                return 'Data inválida';
            }
            const parts = dateString.split('-');
            if (parts.length !== 3) return 'Data inválida';
            const [year, month, day] = parts;
            return `${day}/${month}/${year}`;
        }

        function setSalary() {
            const salaryInput = document.getElementById('salaryAmount');
            const salaryValue = parseFloat(salaryInput.value);

            if (!isNaN(salaryValue) && salaryValue >= 0) {
                // Atualiza o salário no objeto `monthlyData` para o mês atual
                if (!monthlyData[currentMonth]) {
                    monthlyData[currentMonth] = { entries: [], salary: 0 };
                }
                monthlyData[currentMonth].salary = salaryValue;
                salary = salaryValue; // Atualiza a variável global `salary`

                saveMonthlyData(); // Salva no Firebase (e/ou localStorage)

                salaryInput.value = ''; // Limpa o input
                updateSalaryDisplay();
                updateRemaining();
            } else {
                alert('Por favor, insira um valor de salário válido (positivo ou zero).');
            }
        }

        function updateSalaryDisplay() {
            const salaryElement = document.getElementById('currentSalary');
            if (salaryElement) {
                salaryElement.textContent = salary > 0 && !isPrivacyMode ? formatCurrency(salary) : '';
            }
        }

        function updateTable() {
            const tableBody = document.getElementById('entryTableBody');
            if (!tableBody) return;
            tableBody.innerHTML = '';

            const currentEntries = monthlyData[currentMonth]?.entries || [];

            currentEntries.forEach((entry, index) => {
                const row = document.createElement('tr');
                const valueColor = entry.type === 'income' ? 'var(--remaining-color)' : 'var(--remaining-negative-color)';
                const displayValue = isPrivacyMode ? '****' : formatCurrency(entry.amount);
                const paidIcon = entry.isPaid ? '<i class="fas fa-check paid-icon"></i>' : '';

                row.innerHTML = `
                    <td style="cursor: pointer;" data-action="toggle-paid" data-index="${index}">${paidIcon} ${entry.name}${entry.isRecurring ? ' <i class="fas fa-redo-alt recurring-icon"></i>' : ''}</td>
                    <td style="color: ${valueColor}">${displayValue}</td>
                    <td>${formatDate(entry.date)}</td>
                    <td>
                        <button class="edit-btn" data-index="${index}"><i class="fas fa-edit"></i> Editar</button>
                        <button class="delete-btn" data-index="${index}"><i class="fas fa-trash"></i> Excluir</button>
                    </td>
                `;
                tableBody.appendChild(row);
            });
        }

        function updateTotal() {
            const currentEntries = monthlyData[currentMonth]?.entries || [];
            const totalExpenses = currentEntries
                .filter(entry => entry.type === 'expense')
                .reduce((sum, entry) => sum + parseFloat(entry.amount || 0), 0);

            const totalAmountElement = document.getElementById('totalAmount');
            if (isPrivacyMode) {
                totalAmountElement.textContent = 'Total de Gastos: ****';
            } else {
                totalAmountElement.textContent = `Total de Gastos: ${formatCurrency(totalExpenses)}`;
            }

            return totalExpenses; // Retorna o valor para ser usado em outros cálculos
        }

        function updateRemaining() {
            const totalExpenses = updateTotal(); // Já atualiza o display de total
            const currentEntries = monthlyData[currentMonth]?.entries || [];
            const currentSalary = monthlyData[currentMonth]?.salary || 0;

            const totalIncome = currentEntries
                .filter(entry => entry.type === 'income')
                .reduce((sum, entry) => sum + parseFloat(entry.amount || 0), 0);

            const totalBudget = currentSalary + totalIncome;
            const remaining = totalBudget - totalExpenses;

            const remainingElement = document.getElementById('remainingAmount');
            if (isPrivacyMode) {
                remainingElement.textContent = 'Restante: ****';
                remainingElement.classList.remove('negative');
            } else {
                remainingElement.textContent = `Restante: ${formatCurrency(remaining)}`;
                remainingElement.classList.toggle('negative', remaining < 0);
            }
        }

        function updateToPay() {
            const currentEntries = monthlyData[currentMonth]?.entries || [];
            const totalToPay = currentEntries
                .filter(entry => entry.type === 'expense' && !entry.isPaid)
                .reduce((sum, entry) => sum + parseFloat(entry.amount || 0), 0);

            const toPayElement = document.getElementById('toPayAmount');
            if (isPrivacyMode) {
                toPayElement.textContent = 'A pagar: ****';
                toPayElement.classList.remove('negative');
            } else {
                toPayElement.textContent = `A pagar: ${formatCurrency(totalToPay)}`;
                toPayElement.classList.toggle('negative', totalToPay > 0);
            }
        }

        function updateChart() {
            const chartContainer = document.getElementById('entryChart');
            if (!chartContainer) return;
            const ctx = chartContainer.getContext('2d');
            const isDarkTheme = document.body.getAttribute('data-theme') === 'dark';

            if (isPrivacyMode) {
                if (chart) chart.destroy();
                ctx.canvas.style.display = 'none';
                return;
            }
            ctx.canvas.style.display = 'block';

            const currentEntries = monthlyData[currentMonth]?.entries || [];
            const currentSalaryValue = monthlyData[currentMonth]?.salary || 0;

            const totalExpenses = currentEntries
                .filter(entry => entry.type === 'expense')
                .reduce((sum, entry) => sum + parseFloat(entry.amount || 0), 0);
            const totalIncome = currentEntries
                .filter(entry => entry.type === 'income')
                .reduce((sum, entry) => sum + parseFloat(entry.amount || 0), 0);

            const totalBudget = currentSalaryValue + totalIncome;
            const remainingForChart = totalBudget > 0 ? Math.max(totalBudget - totalExpenses, 0) : 0;

            const expenseLabels = currentEntries.filter(entry => entry.type === 'expense').map(entry => entry.name);
            const expenseData = currentEntries.filter(entry => entry.type === 'expense').map(entry => parseFloat(entry.amount || 0));

            const labels = [...expenseLabels];
            const data = [...expenseData];
            const hasRemainingOrIncome = (remainingForChart > 0 && totalBudget > 0);

            if (hasRemainingOrIncome) {
                labels.push('Disponível (Salário + Rendas - Gastos)');
                data.push(remainingForChart);
            } else if (totalBudget <= 0 && totalExpenses === 0) { // Caso não haja dados
                if (chart) chart.destroy();
                // Opcional: mostrar mensagem de "sem dados para o gráfico"
                return;
            }

            const expenseColors = isDarkTheme
                ? ['#4CAF50', '#29B6F6', '#F44336', '#78909C', '#FFB300', '#CE93D8']
                : ['#66BB6A', '#42A5F5', '#EF5350', '#90A4AE', '#FFCA28', '#AB47BC'];
            const remainingBaseColor = isDarkTheme ? 'rgba(128, 128, 128, 0.7)' : 'rgba(211, 211, 211, 0.7)';

            const backgroundColors = expenseData.map((_, index) => expenseColors[index % expenseColors.length]);
            if (hasRemainingOrIncome) {
                backgroundColors.push(remainingBaseColor);
            }

            if (chart) chart.destroy();
            chart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: isDarkTheme ? '#1e1e1e' : '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { color: isDarkTheme ? '#e0e0e0' : '#2d3436', font: { family: 'Poppins', size: 12 } }
                        },
                        tooltip: {
                            callbacks: { label: (context) => `${context.label}: ${formatCurrency(context.raw)}` }
                        }
                    }
                }
            });
        }

        function getMonthIndex(monthName) {
            return months.indexOf(monthName);
        }

        function getLastDayOfMonth(year, monthIndex) { // monthIndex 0-11
            return new Date(year, monthIndex + 1, 0).getDate();
        }

        function addRecurringEntries(entryData, startMonthIndexParam) {
            const user = auth.currentUser;
            if (!user) return; // Não faz nada se não houver usuário

            const [yearStr, monthStr, dayStr] = entryData.date.split('-');
            const parsedYear = parseInt(yearStr);
            const parsedDay = parseInt(dayStr);

            // O startMonthIndexParam é o índice do mês onde a entrada original foi adicionada/editada
            // Se estamos editando, e a recorrência é mantida ou adicionada,
            // as entradas futuras a partir da data original devem ser consideradas.
            const originalEntryMonthIndex = parseInt(monthStr) - 1;
            const actualStartMonthIndexForLoop = editingIndex !== null ? originalEntryMonthIndex : startMonthIndexParam;


            for (let i = actualStartMonthIndexForLoop; i < months.length; i++) {
                const targetMonthName = months[i];
                const lastDay = getLastDayOfMonth(parsedYear, i); // i é o índice do mês (0-11)
                const targetDay = Math.min(parsedDay, lastDay);
                const targetDate = `${parsedYear}-${String(i + 1).padStart(2, '0')}-${String(targetDay).padStart(2, '0')}`;

                const newRecurringEntry = {
                    ...entryData, // name, amount, type
                    date: targetDate,
                    isRecurring: true, // Garante que a flag de recorrência está correta
                    isPaid: false // Novas entradas recorrentes futuras começam como não pagas
                };

                // Adiciona ou atualiza no objeto monthlyData local
                if (!monthlyData[targetMonthName]) {
                    monthlyData[targetMonthName] = { entries: [], salary: 0 };
                }

                // Se estamos editando a entrada original (i == actualStartMonthIndexForLoop) E é o mês da edição
                if (i === originalEntryMonthIndex && editingIndex !== null && targetMonthName === currentMonth) {
                    monthlyData[targetMonthName].entries[editingIndex] = newRecurringEntry;
                } else {
                    // Para meses futuros ou se for uma nova entrada recorrente
                    // Evitar duplicatas se a entrada já existe e é a mesma
                    const existingEntryIndex = monthlyData[targetMonthName].entries.findIndex(e =>
                        e.name === newRecurringEntry.name &&
                        e.amount === newRecurringEntry.amount &&
                        e.type === newRecurringEntry.type &&
                        e.date.substring(0, 7) === newRecurringEntry.date.substring(0, 7) // Compara ano e mês
                    );

                    if (existingEntryIndex === -1) {
                        monthlyData[targetMonthName].entries.push(newRecurringEntry);
                    } else {
                        // Se já existe uma entrada similar no mesmo mês (ex: de uma edição anterior),
                        // podemos decidir sobrescrevê-la ou ignorar.
                        // Por simplicidade, vamos sobrescrever se for para o mesmo nome/tipo/mês,
                        // assumindo que é uma atualização da intenção recorrente.
                        monthlyData[targetMonthName].entries[existingEntryIndex] = newRecurringEntry;
                    }
                }
                // Salva os dados do mês específico no Firebase
                const monthDataRef = ref(database, `users/${user.uid}/monthlyData/${targetMonthName}`);
                set(monthDataRef, monthlyData[targetMonthName]);
            }
        }

        function removeRecurringEntries(entryName, entryAmount, entryType, originalDateStr, fromMonthName) {
            const user = auth.currentUser;
            if (!user) return;

            const [originalYear] = originalDateStr.split('-');
            const startRemovingMonthIndex = getMonthIndex(fromMonthName);

            for (let i = startRemovingMonthIndex; i < months.length; i++) {
                const targetMonthName = months[i];
                if (monthlyData[targetMonthName] && monthlyData[targetMonthName].entries) {
                    monthlyData[targetMonthName].entries = monthlyData[targetMonthName].entries.filter(e => {
                        const [entryYear] = e.date.split('-');
                        // Não remove se não for recorrente, ou se o nome/valor/tipo não bater, ou se for de outro ano
                        if (!e.isRecurring || e.name !== entryName || e.amount !== entryAmount || e.type !== entryType || entryYear !== originalYear) {
                            return true;
                        }
                        return false; // Remove a entrada recorrente correspondente
                    });
                    // Salva os dados do mês específico no Firebase após a remoção
                    const monthDataRef = ref(database, `users/${user.uid}/monthlyData/${targetMonthName}`);
                    set(monthDataRef, monthlyData[targetMonthName]);
                }
            }
        }


        function toggleRecurringOption() { // Esta função pode ser simplificada ou removida
            // A visibilidade do recurringOption pode ser controlada por CSS ou no HTML diretamente
            const recurringOption = document.getElementById('recurringOption');
            if (recurringOption) recurringOption.style.display = 'block'; // ou 'flex' dependendo do seu CSS
        }

        function addOrUpdateEntry() {
            const nameInput = document.getElementById('entryName');
            const amountInput = document.getElementById('entryAmount');
            const dateInput = document.getElementById('entryDate');
            const type = document.querySelector('input[name="entryType"]:checked').value;
            const isRecurringInput = document.getElementById('isRecurring');

            const name = nameInput.value.trim();
            const amount = parseFloat(amountInput.value);
            const dateStr = dateInput.value; // yyyy-mm-dd
            const isRecurring = isRecurringInput.checked;

            if (!name || isNaN(amount) || amount <= 0 || !dateStr) {
                alert('Por favor, preencha todos os campos corretamente: nome, valor positivo e data.');
                return;
            }

            const [year, monthNumStr, day] = dateStr.split('-'); // monthNumStr é "01" a "12"
            const entryMonthIndex = parseInt(monthNumStr, 10) - 1; // 0-11
            const entryMonthName = months[entryMonthIndex];

            const entryData = { name, amount, date: dateStr, type, isRecurring, isPaid: false };

            // Garante que a estrutura para o mês da entrada exista
            if (!monthlyData[entryMonthName]) {
                monthlyData[entryMonthName] = { entries: [], salary: 0 };
            }
            if (!monthlyData[entryMonthName].entries) {
                monthlyData[entryMonthName].entries = [];
            }

            if (editingIndex !== null) { // Editando uma entrada existente
                const oldEntry = monthlyData[currentMonth].entries[editingIndex];

                // Se a recorrência mudou de true para false, ou se a entrada não é mais recorrente
                if (oldEntry.isRecurring && !isRecurring) {
                    removeRecurringEntries(oldEntry.name, oldEntry.amount, oldEntry.type, oldEntry.date, currentMonth);
                }

                monthlyData[currentMonth].entries[editingIndex] = entryData; // Atualiza a entrada no mês atual

                if (isRecurring) { // Se AGORA é recorrente (seja uma nova recorrência ou mantendo uma existente)
                    // A função addRecurringEntries deve lidar com a atualização ou criação de entradas futuras
                    addRecurringEntries(entryData, entryMonthIndex);
                }

            } else { // Adicionando uma nova entrada
                monthlyData[entryMonthName].entries.push(entryData);
                if (isRecurring) {
                    addRecurringEntries(entryData, entryMonthIndex);
                }
            }

            saveMonthlyDataForCurrent(); // Salva os dados do mês atual (entryMonthName)

            // Limpa os campos e redefine o estado de edição
            nameInput.value = '';
            amountInput.value = '';
            dateInput.value = '';
            isRecurringInput.checked = false;
            document.querySelector('input[name="entryType"][value="expense"]').checked = true;

            if (editingIndex !== null) {
                document.getElementById('addBtn').innerHTML = '<i class="fas fa-plus"></i> Adicionar';
                document.getElementById('cancelBtn').style.display = 'none';
                editingIndex = null;
            }

            // Recarrega os dados e atualiza a UI para o mês onde a entrada foi adicionada/editada
            // Se entryMonthName for diferente de currentMonth, precisamos mudar para ele
            if (currentMonth !== entryMonthName) {
                document.getElementById('monthSelect').value = entryMonthName;
                changeMonth(); // Isso vai chamar loadMonthData para o novo mês
            } else {
                loadMonthData(); // Recarrega dados para o mês atual
            }
        }

        function saveMonthlyDataForCurrent() { // Função específica para salvar o mês corrente da entrada
            const user = auth.currentUser;
            const monthToSave = editingIndex !== null ? currentMonth : months[parseInt(document.getElementById('entryDate').value.split('-')[1], 10) - 1];

            if (user && monthToSave && monthlyData[monthToSave]) {
                const monthDataRef = ref(database, `users/${user.uid}/monthlyData/${monthToSave}`);
                set(monthDataRef, monthlyData[monthToSave])
                    .then(() => console.log(`Dados para ${monthToSave} (entrada) salvos no Firebase.`))
                    .catch(error => console.error(`Erro ao salvar ${monthToSave} (entrada):`, error));
            }
        }


        function editEntry(index) {
            // Certifique-se que 'entries' se refere aos dados do 'currentMonth'
            const entriesForCurrentMonth = monthlyData[currentMonth]?.entries || [];
            if (index < 0 || index >= entriesForCurrentMonth.length) return;

            const entry = entriesForCurrentMonth[index];
            document.getElementById('entryName').value = entry.name;
            document.getElementById('entryAmount').value = entry.amount.toFixed(2);
            document.getElementById('entryDate').value = entry.date;
            document.getElementById('isRecurring').checked = entry.isRecurring;
            document.querySelector(`input[name="entryType"][value="${entry.type}"]`).checked = true;

            document.getElementById('addBtn').innerHTML = '<i class="fas fa-save"></i> Salvar Alterações';
            document.getElementById('cancelBtn').style.display = 'inline-block'; // ou 'flex'
            editingIndex = index;
        }

        function cancelEdit() {
            document.getElementById('entryName').value = '';
            document.getElementById('entryAmount').value = '';
            document.getElementById('entryDate').value = '';
            document.getElementById('isRecurring').checked = false;
            document.querySelector('input[name="entryType"][value="expense"]').checked = true;

            document.getElementById('addBtn').innerHTML = '<i class="fas fa-plus"></i> Adicionar';
            document.getElementById('cancelBtn').style.display = 'none';
            editingIndex = null;
        }

        function deleteEntry(index) {
            const entriesForCurrentMonth = monthlyData[currentMonth]?.entries || [];
            if (index < 0 || index >= entriesForCurrentMonth.length) return;

            const entryToDelete = { ...entriesForCurrentMonth[index] }; // Copia a entrada
            let confirmMessage = `Tem certeza que deseja excluir "${entryToDelete.name}"?`;

            if (entryToDelete.isRecurring) {
                const choice = confirm(
                    `"${entryToDelete.name}" é uma entrada recorrente.\n` +
                    `OK: Excluir APENAS a ocorrência de ${currentMonth}.\n` +
                    `Cancelar: Excluir TODAS as ocorrências futuras (a partir de ${currentMonth}).`
                );

                if (choice) { // Excluir apenas neste mês
                    confirmMessage = `Excluir "${entryToDelete.name}" apenas de ${currentMonth}?`;
                    if (confirm(confirmMessage)) {
                        entriesForCurrentMonth.splice(index, 1);
                        // Se era recorrente, mas só esta instância foi removida, a entrada em si não é mais recorrente *neste mês*.
                        // No entanto, a flag isRecurring na entrada original (se editada) não deve mudar globalmente aqui.
                        // Apenas removemos esta instância.
                    } else return; // Cancelou a exclusão específica
                } else { // Excluir todas as futuras
                    confirmMessage = `Excluir TODAS as ocorrências futuras de "${entryToDelete.name}" a partir de ${currentMonth}?`;
                    if (confirm(confirmMessage)) {
                        removeRecurringEntries(entryToDelete.name, entryToDelete.amount, entryToDelete.type, entryToDelete.date, currentMonth);
                        // Como removeRecurringEntries já lida com a remoção do mês atual também,
                        // não precisamos fazer splice adicional aqui se ele já removeu.
                        // Mas, para garantir que a UI reflita imediatamente no mês atual se removeRecurringEntries
                        // não fizer o splice para o currentMonth (se a lógica for estritamente "futuras"),
                        // podemos fazer o splice. No entanto, a lógica atual de removeRecurringEntries deve cobrir.
                        // Por segurança, após removeRecurringEntries, recarregamos os dados.
                        loadMonthData();
                        return;
                    } else return; // Cancelou a exclusão de todas
                }
            } else { // Não é recorrente
                if (!confirm(confirmMessage)) return;
                entriesForCurrentMonth.splice(index, 1);
            }

            monthlyData[currentMonth].entries = entriesForCurrentMonth; // Atualiza o array no objeto global
            saveMonthlyData(); // Salva as alterações no Firebase
            loadMonthData(); // Recarrega e atualiza a UI
        }

        function changeMonth() {
            currentMonth = document.getElementById('monthSelect').value;
            loadMonthData(); // Carrega dados para o novo mês selecionado
        }

        function togglePrivacyMode() {
            isPrivacyMode = !isPrivacyMode;
            localStorage.setItem('app2_privacyMode', isPrivacyMode.toString());
            const icon = document.getElementById('privacyToggle').querySelector('i');
            icon.classList.toggle('fa-eye', !isPrivacyMode);
            icon.classList.toggle('fa-eye-slash', isPrivacyMode);
            // Recarregar/Re-renderizar os componentes que dependem do modo de privacidade
            updateSalaryDisplay();
            updateTable(); // Precisa re-renderizar a tabela para mostrar/ocultar valores
            updateRemaining();
            updateToPay();
            updateChart();
        }

        function togglePaid(index) {
            const entriesForCurrentMonth = monthlyData[currentMonth]?.entries || [];
            if (index < 0 || index >= entriesForCurrentMonth.length) return;

            entriesForCurrentMonth[index].isPaid = !entriesForCurrentMonth[index].isPaid;
            monthlyData[currentMonth].entries = entriesForCurrentMonth; // Atualiza o array no objeto global

            saveMonthlyData(); // Salva no Firebase
            // Apenas atualiza a tabela e o "a pagar", não precisa recarregar tudo
            updateTable();
            updateToPay();
        }

        // --- Event Listeners Globais e Inicialização ---
        document.addEventListener('DOMContentLoaded', () => {
            const settingsMenuBtn = document.getElementById('settingsMenuBtn');
            const darkModeToggle = document.getElementById('darkModeToggle');
            const paymentDayInput = document.getElementById('paymentDay');
            const setSalaryBtn = document.getElementById('setSalaryBtn');
            const monthSelect = document.getElementById('monthSelect');
            const privacyToggleBtn = document.getElementById('privacyToggle');
            const addBtn = document.getElementById('addBtn');
            const cancelBtn = document.getElementById('cancelBtn');
            const entryTable = document.getElementById('entryTable'); // Escuta na tabela inteira

            // NOVO: Adicione os listeners para os botões de login/registro
            const loginBtn = document.getElementById('loginBtn');
            if (loginBtn) {
                loginBtn.addEventListener('click', handleLogin);
            }
            const registerBtn = document.getElementById('registerBtn');
            if (registerBtn) {
                registerBtn.addEventListener('click', handleRegistration);
            }

            // Botões de Login/Logout (já definidos fora do DOMContentLoaded, mas poderiam estar aqui)
            const googleLoginButton = document.getElementById('googleSignInBtn');
            if (googleLoginButton) {
                googleLoginButton.addEventListener('click', signInWithGoogle);
            }
            const appSignOutButton = document.getElementById('signOutBtn');
            if (appSignOutButton) {
                appSignOutButton.addEventListener('click', signOutUser);
            }

            if (settingsMenuBtn) settingsMenuBtn.addEventListener('click', toggleSettingsMenu);
            if (darkModeToggle) darkModeToggle.addEventListener('change', toggleTheme);
            if (paymentDayInput) paymentDayInput.addEventListener('change', setPaymentDay);
            if (setSalaryBtn) setSalaryBtn.addEventListener('click', setSalary);
            if (monthSelect) monthSelect.addEventListener('change', changeMonth);
            if (privacyToggleBtn) privacyToggleBtn.addEventListener('click', togglePrivacyMode);
            if (addBtn) addBtn.addEventListener('click', addOrUpdateEntry);
            if (cancelBtn) cancelBtn.addEventListener('click', cancelEdit);

            if (entryTable) {
                entryTable.addEventListener('click', (event) => {
                    const target = event.target;
                    const actionButton = target.closest('button[data-index]'); // Para edit/delete
                    const actionCell = target.closest('td[data-action="toggle-paid"]'); // Para toggle-paid

                    if (actionButton) {
                        const index = parseInt(actionButton.getAttribute('data-index'));
                        if (!isNaN(index)) {
                            if (actionButton.classList.contains('edit-btn')) {
                                editEntry(index);
                            } else if (actionButton.classList.contains('delete-btn')) {
                                deleteEntry(index);
                            }
                        }
                    } else if (actionCell) {
                        const index = parseInt(actionCell.getAttribute('data-index'));
                        if (!isNaN(index)) {
                            togglePaid(index);
                        }
                    }
                });
            }

            document.addEventListener('click', (event) => {
                const menu = document.getElementById('settingsMenu');
                const menuButton = document.getElementById('settingsMenuBtn'); // Usar o ID
                if (menuButton && menu && !menu.contains(event.target) && !menuButton.contains(event.target) && !menuButton.querySelector('i').contains(event.target)) {
                    menu.classList.remove('active');
                }
            });

            document.querySelectorAll('input[name="entryType"]').forEach(radio => {
                radio.addEventListener('change', toggleRecurringOption);
            });

            // `onAuthStateChanged` vai chamar `setupAppUI` que por sua vez chama `loadMonthData`.
            // Não é necessário chamar `checkAuthentication` ou `initializeApp` do sistema antigo aqui.
            // A lógica de carregamento inicial é disparada pelo `onAuthStateChanged`.
        });
    </script>
</body>

</html>